package main

import (
        "crypto/tls"
        "flag"
        "fmt"
        "log"
        "os"
        "path"
        "sync"
        "context"
        "strings"
        "encoding/json"
        "strconv"

        "github.com/gorilla/websocket"
        "github.com/pion/webrtc/v3"
        "github.com/pion/ice/v2"

        "webrtc-client-go/wmsg"
        "webrtc-client-go/wcodec"
)

var Usage = func() {
        fmt.Fprintf(os.Stderr, "%s [args]\n", path.Base(os.Args[0]))
        flag.PrintDefaults()
        os.Exit(1)
}

const (
        FREE int = iota
        SETUP
        BUSY
)

const DefaultUrl = "ws://localhost:8443/"

// must be called when holding the candidateLock
func processCachedCandidates(pc *webrtc.PeerConnection, cache []webrtc.ICECandidateInit) () {
        for len(cache) > 0 {
                var c webrtc.ICECandidateInit
                c, cache = cache[0], cache[1:]
                log.Println("Adding cached remote ICE candidate:", c,
                        "SdpMid:", *c.SDPMid, "SdpMLineIndex:", *c.SDPMLineIndex)
                if candidateErr := pc.AddICECandidate(c); candidateErr != nil {
                        log.Fatal(candidateErr)
                }
        }
}

func dumpCandidates(tr *webrtc.ICETransport) () {
        pair, err := tr.GetSelectedCandidatePair()
        if err != nil { return }
        log.Printf("LOCAL candidate: %s", pair.Local.String())
        log.Printf("REMOTE candidate: %s", pair.Remote.String())
}


/////////////////////////

func main() {
        var pid = os.Getpid()
        state := FREE
        log.SetFlags(log.LstdFlags | log.Lshortfile)

        if len(os.Args) < 1  {
                Usage()
        }

        // cmd line
        Url      := flag.String("url", DefaultUrl, "WebRtc server URL")
        TLSDebug := flag.Bool("debug", false, "Debug the TLS connection using a keylogger: dumps data into /tmp/keylog")
        file     := flag.String("file", "", "media file to play (extension is either h264 or vp8/ivf, this selects receiver side codec)")
        stunURI  := flag.String("turn", "", "STUN/TURN server URI")
        flag.Parse();

        // Assert that we have an audio or video file
        _, err := os.Stat(*file)
        if os.IsNotExist(err) {
                log.Fatalf("Could not open file `%s`: %s\n", file, err)
        }

        // Select codec type
        codec := webrtc.MimeTypeH264
        switch strings.ToLower(path.Ext(*file)){
        case ".h264", ".mkv":
                codec = webrtc.MimeTypeH264
        case ".vp8", ".ivf":
                codec = webrtc.MimeTypeVP8
        default:
                log.Fatalf("Unknown codec %s: file extension must be either mkv/h264 or vp8/ivf",
                        strings.ToLower(path.Ext(*file)))
        }

        log.Printf("Starting video: %s\n", *file)

        //server uses self-signed certificate: switch to insecure TLS mode
        dialer := *websocket.DefaultDialer
        dialer.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
        if *TLSDebug {
                kl, err := os.OpenFile("/tmp/keylog", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
                if err != nil {
                        log.Fatal("keylog:", err)
                }
                defer kl.Close()
                dialer.TLSClientConfig.KeyLogWriter = kl
                fmt.Fprintf(kl, "# SSL/TLS secrets log file, generated by go\n")
        }

        // connect to the webrtc-server
        log.Printf("connecting to %s", *Url)
        c, _, err := dialer.Dial(*Url, nil)
        if err != nil {
                log.Fatalln("dial:", err)
        }
        defer c.Close()

        // setup a peerconnection so that we can generate an SDP
        s := webrtc.SettingEngine{}

        // we are not interested in TPC or anything IPv6 for simplicity
        s.SetNetworkTypes([]webrtc.NetworkType{webrtc.NetworkTypeUDP4})

        // disable Multicast DNS
        s.SetICEMulticastDNSMode(ice.MulticastDNSModeDisabled)
        s.SetAnsweringDTLSRole(webrtc.DTLSRoleServer)

        // set up media codecs to enforce transcoding (use m.RegisterDefaultCodecs() if transcoding
        // is not needed
        m := &webrtc.MediaEngine{}

        var regCodecs []webrtc.RTPCodecParameters
        switch codec {
        case webrtc.MimeTypeVP8:
                regCodecs = wcodec.VP8Codecs
        case webrtc.MimeTypeH264:
                regCodecs = wcodec.H264Codecs
        }

        for _, c := range regCodecs {
                if err := m.RegisterCodec(c, webrtc.RTPCodecTypeVideo); err != nil {
                        log.Fatalln("Could not register codec:", c)
                }
        }

        if(*stunURI != ""){
                log.Println("using STUN/TURN/ICE server:", *stunURI)
        }
        config := webrtc.Configuration{
                ICEServers: []webrtc.ICEServer{
                        {
                                URLs:           []string{*stunURI},
                                Username:       "user-1",
                                Credential:     "pass-1",
                                CredentialType: webrtc.ICECredentialTypePassword,
                        },
                },
                ICETransportPolicy: webrtc.ICETransportPolicyRelay,
        }

        peerConnection, err :=
                webrtc.NewAPI(webrtc.WithSettingEngine(s),webrtc.WithMediaEngine(m)).NewPeerConnection(config)
        if err != nil {
                log.Fatalln("NewPeerConnection:", err)
        }
        defer peerConnection.Close()

        peerConnection.OnSignalingStateChange(func(ss webrtc.SignalingState) {
                log.Println("Signaling state change:", ss)
        })

        // Set the handler for ICE connection state
        // This will notify you when the peer has connected/disconnected
        iceConnectedCtx, iceConnectedCtxCancel := context.WithCancel(context.Background())
        peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
                log.Println("Connection state change:", connectionState.String())
                switch connectionState {
                case webrtc.ICEConnectionStateConnected:
                        // dump active transport
                        senders := peerConnection.GetSenders()
                        for _, t := range senders {
                                dumpCandidates(t.Transport().ICETransport())
                        }
                        receivers := peerConnection.GetReceivers()
                        for _, t := range receivers {
                                dumpCandidates(t.Transport().ICETransport())
                        }
                        iceConnectedCtxCancel()
                case webrtc.ICEConnectionStateDisconnected, webrtc.ICEConnectionStateFailed:
                        log.Fatalln("Disconnected/failed, exiting")
                }
        })

        // reader: get messages from the webrtc-server
        candidateLock := sync.RWMutex{}
        candidateCache := []webrtc.ICECandidateInit{}
        recv := make(chan map[string]interface{})
        go func() {
                defer close(recv)
                for {
                        _, message, err := c.ReadMessage()
                        if err != nil {
                                // if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {
                                //      log.Fatalf("trying to read from closed websocket: %s\n", err)
                                // }
                                log.Println("readMessage:", err)
                                // if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {
                                        // return
                                // }
                                return
                        }

                        log.Printf("recv: %s\n", message)

                        // dunno the types yet, try to unmarschal
                        m := map[string]interface{}{}
                        err = json.Unmarshal(message, &m)
                        if err != nil {
                                log.Println("JSON unmarschal:", err)
                                continue
                        }

                        log.Printf("recv: %v", m)

                        // handle REMOTE ICECandidates: cache or add
                        if m["id"].(string) == "iceCandidate" {
                                c := m["candidate"].(map[string]interface{})
                                sdpmid := c["sdpMid"].(string)
                                sdpmlineindex := uint16(c["sdpMLineIndex"].(float64))
                                candidate := webrtc.ICECandidateInit{
                                        Candidate: c["candidate"].(string),
                                        SDPMid: &sdpmid,
                                        SDPMLineIndex: &sdpmlineindex,
                                }
                                if peerConnection.RemoteDescription() == nil {
                                        // no remote SDP yet, cache candidate
                                        log.Println("Caching remote ICE candidate:", candidate,
                                                "SdpMid:", *candidate.SDPMid,
                                                "SdpMLineIndex:", *candidate.SDPMLineIndex)
                                        candidateLock.Lock()
                                        candidateCache = append(candidateCache, candidate)
                                        candidateLock.Unlock()
                                } else {
                                        log.Println("Adding remote ICE candidate:", candidate,
                                                "SdpMid:", *candidate.SDPMid,
                                                "SdpMLineIndex:", *candidate.SDPMLineIndex)
                                        if candidateErr := peerConnection.AddICECandidate(candidate); candidateErr != nil {
                                                log.Fatal(candidateErr)
                                        }
                                }
                                continue;
                        }

                        recv <- m
                }
        }()

        // sender: write messages to the webrtc-server
        send := make(chan wmsg.Message)
        go func() {
                defer close(send)
                for s := range send {
                        log.Printf("send: %s\n", s)
                        err := c.WriteJSON(s)
                        if err != nil {
                                log.Println("WriteJSON:", err)
                                return
                        }
                }
        }()

        // handle LOCAL ICE candidates
        // channel that is blocked until LOCAL!! ICE Gathering is complete
        gatherComplete := webrtc.GatheringCompletePromise(peerConnection)
        peerConnection.OnICECandidate(func(i *webrtc.ICECandidate) {
                if i != nil {
                        send <- wmsg.NewOnICECandidate(i)
                }
        })

        log.Printf("Starting magic mirror call with pid: " + strconv.Itoa(pid))

        // // Set a handler for when a new remote track starts
        peerConnection.OnTrack(wcodec.ReceiveTrack(peerConnection, "mirrored_" + strconv.Itoa(pid), codec))

        // audio&video
        videoTrack, videoTrackErr := webrtc.NewTrackLocalStaticSample(
                webrtc.RTPCodecCapability{MimeType: codec}, "video", "pion")
        if videoTrackErr != nil {
                log.Fatalln(videoTrackErr)
        }

        rtpSender, videoTrackErr := peerConnection.AddTrack(videoTrack)
        if videoTrackErr != nil {
                log.Fatalln(videoTrackErr)
        }

        wcodec.SendFile(iceConnectedCtx, rtpSender, *file, codec, videoTrack)

        offer, err := peerConnection.CreateOffer(nil)
        if err != nil {
                log.Fatalln("cannot create offer:", err)
        }

        if err = peerConnection.SetLocalDescription(offer); err != nil {
                log.Fatalln("cannot set local SDP:", err)
        }

        state = SETUP
        send <- wmsg.NewMagicMirrorRequest(offer.SDP)

        // wait for a call response
        var call_res wmsg.MagicMirrorResponse
        for {
                call_res, err = wmsg.NewMagicMirrorResponse(<- recv)
                if err != nil {
                        log.Println("NewMagicMirrorResponse:", err)
                        continue
                }
                break
        }
        // log.Println("call response:", call_res.Response)

        state = BUSY
        log.Println("new state:", state)

        // remove conflicting fingerprints from SDP
        desc, errSdp := wmsg.ParseSdp(webrtc.SDPTypeAnswer, call_res.Sdp)
        if errSdp != nil {
                log.Fatalln("could not parse SDP answer:", errSdp)
        }

        log.Printf("Setting remote session description: %v\n", *desc)
        err = peerConnection.SetRemoteDescription(*desc)
        if err != nil {
                log.Fatalln("cannot set remote SDP:", err)
        }

        <-gatherComplete

        // process remaining cached REMOTE ICE candidates
        candidateLock.Lock()
        processCachedCandidates(peerConnection, candidateCache);
        candidateLock.Unlock()

        log.Println("connection setup ready")

        // Start pushing buffers on these tracks

        // Block forever
        select {}

        os.Exit(0)

}
